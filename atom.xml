<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tamaloa's Blog</title>
 <link href="http://tamaloa.github.io/" rel="self"/>
 <link href="http://tamaloa.github.io"/>
 <updated>2017-01-22T19:43:39+01:00</updated>
 <id>http://tamaloa.github.io</id>
 <author>
   <name>Michael</name>
   <email></email>
 </author>

 
 <entry>
   <title>More Advanced Features for Our Grape API</title>
   <link href="http://tamaloa.github.io/2016/12/08/more-advanced-features-for-our-grape-api"/>
   <updated>2016-12-08T00:00:00+01:00</updated>
   <id>http://tamaloa.github.io/2016/12/08/more-advanced-features-for-our-grape-api</id>
   <content type="html">

After we got our intitial first Grape API up and running (including the nice swagger documentation) we started adding more features.

* Entities &amp; Doc configuration
* authentication via token
* CORS configuration
* JSON:API
* caching

.h3 Configuring the Swagger documentation

As nice as the default generated documentation is one always wants to change it around a little. Some stuff we found unnecessary hard to do other was easy.
For instance the list of API endpoints is headed by a line autogenerated from the API class name. This was okay until we modularized everything and added a base API class. Suddenly the heading read &quot;api: Operations about apis&quot; which does not make a lot of sense. This can be configured by adding tags to EVERY route description. Below the example in which we tagged all endpoints except for one:

grape-swagger-tags-example.png

Futhermore details and tags do not play along well. So we had to drop the detailed explaination on one endpoint - will have to investigate this bug later.
Other stuff such as hiding the swagger json url or the token field is simple and done by adding options to the &#39;add_swagger_documentation&#39; call.

.h3 Grape::Entity

We then added an endpoint which returns not only a simple list of values but a more complex model. This seemed the right time to add grape_entity and the corresponding swagger gem. Entities are a kind of decorator, that is a class in which you define what attributes/methods are to be included and in which you also may do some formatting or rename attributes to something your API consumers may understand.

&lt;pre&gt;
module Entities
  class ServiceProvider &lt; Grape::Entity
    expose :full_name, as: :name, documentation: { type: &#39;string&#39;,
            desc: &#39;Service provider company name in latin. If applicable may be followed by company name in non latin spelling.&#39;}
    expose :slug, documentation: { type: &#39;string&#39;, desc: &#39;Unique identifier in human readable form.&#39; }
    expose :url, documentation: { type: &#39;url&#39;, desc: &#39;The URL for this service provider in our application.&#39;}

    private
    def url
       Rails.application.routes.url_helpers.company_url(object, host: Figaro.env.base_url)
    end
  end
end
&lt;/pre&gt;

As you can se we renamed some attributes and included the URL under which a user may visit our entity. Next we used our grape entity to present our actual ActiveRecord objects &#39;present service_providers, with: Entities::service_providers&#39; which gave us a nice and compact json response. We also hoped to easily add the documentation to our Swar UI. This is mainly done by providing &#39;entity: Nirvana::Entities::ServiceProvider&#39; as a description parameter.


.h3 Authentication via Token

We already use a token based authentication for other parts of our existing application. So naturally we want to reuse this feature. The Swagger UI already has a placeholder for an api-key to be entered in the navigation bar, so activating this feature should be easy. And right enough it is simple to configure the Swagger-UI to always add the current_user token to each api request.
&lt;pre&gt;
GrapeSwaggerRails.options.before_action do
  GrapeSwaggerRails.options.api_key_name = &#39;api_token&#39;
  GrapeSwaggerRails.options.api_key_type = &#39;query&#39;
  GrapeSwaggerRails.options.api_key_default_value = current_user.authentication_token
end
&lt;/pre&gt;

So by now the Swagger-UI adds the user specific api_token to every request triggered inside the UI. Of course we now have to ensure the token matches a user. For this we add a helpers block to our base API class with appropiate methods. These can now be used in any mounted API endpoint to authenticate our users.

&lt;pre&gt;
  class API &lt; Grape::API
    helpers do
      def current_user
        User.authenticate_from_token!(params[:api_token])
      end

      def authenticate!
        error!(&#39;401 Unauthorized&#39;, 401) unless current_user
      end
    end
  end

  class Cities &lt; Grape::API
    resource :cities do
      get :all do
        authenticate!
        City.all
      end
  end
&lt;/pre&gt;

I would like to add the authenticate! call to all endpoints as a default, similar to before filters in rails controllers but there does not seem to exist a easy way of doing this so we will live with it for now.
Also currently the documentation does not say anything about the authorization schema and how to use it. A potential user might miss the api_token parameter. In Grape there exists a security_definition schema which can be passed to the generated swagger documentation. Unfortunately this definition is not reflected in Swagger-UI, at least not in the version we use (bundled with grape-swagger-rails version 0.3.0) which is a pitty. Next try was to document the token as additional query parameter. This for one turns out to be a bit much for a nice clean documentation and also the parameter definition has to again be added to each endpoint which generates a lot of code (again some kind of default params for all endpoints would be nice).
I am not yet decided but for now we will instead put some authentication documentation in the general API documentation which is shown in Swagger UI.


.h3 CORS

To allow CORS (cross origin resource sharing) we add the rack-cors gem and set our headers apropriately on the path under which our api is served (this is done in the host rails project&#39;s application.rb).

&lt;pre&gt;
#In config/application.rb

    config.middleware.insert_before 0, &quot;Rack::Cors&quot; do
      allow do
        origins &#39;*&#39;
        resource &#39;/api/*&#39;, :headers =&gt; :any, :methods =&gt; [:get, :post, :options]
      end
    end
&lt;/pre&gt;

To ensure we do not remove our CORS configuration by accident a small integration test (yes you need integration because otherwise rack is not invoked) is added

&lt;pre&gt;
class ApiConfigurationTest &lt; ActionDispatch::IntegrationTest
  test &quot;CORS is set up only for our api&quot; do
    get &#39;/api/something&#39;, nil, &#39;HTTP_ORIGIN&#39; =&gt; &#39;*&#39;
    assert_equal &#39;*&#39;, response.headers[&#39;Access-Control-Allow-Origin&#39;]

    get &#39;/no_corse_for_other_pahts&#39;, nil, &#39;HTTP_ORIGIN&#39; =&gt; &#39;*&#39;
    refute_equal &#39;*&#39;, response.headers[&#39;Access-Control-Allow-Origin&#39;]
  end
end
&lt;/pre&gt;


.h3 And now? 

So we still had JSON:API and caching on our todo list but the above took long enough so i will call it a day.
Seems that JSON:API is not that easily integrated into grape. There exists some basic implementations which are quite limited (for instance do not support paging). So we will leave this for some other time.
And other usefull stuff which you really should use in production (caching, throtteling, loggging) will be left for some other time.</content>
 </entry>
 
 <entry>
   <title>Using Grape to add an API to a brownfield Rails Project</title>
   <link href="http://tamaloa.github.io/2016/12/05/using-grape-to-add-an-api-to-a-brownfield-rails-project"/>
   <updated>2016-12-05T00:00:00+01:00</updated>
   <id>http://tamaloa.github.io/2016/12/05/using-grape-to-add-an-api-to-a-brownfield-rails-project</id>
   <content type="html">

Starting point: We needed a small and simple API added to a several year old rails 4.2 project. We already have some APIs in use in this project which use basic rails controllers, ActiveModel, and sometimes jbuilder. So quickest would be to just build the API as we did with all the others. Maybe even use newish rails 5 ActionController::API and use &quot;json:api&quot;:http://jsonapi.org/ setting to have some kind of standardization. Up to now we never needed real documentation (beside the code) as we ourselves consumed the APIs. What seems a nice option for API-docus is to use the test cases to generate the documentation as does &quot;rspec_api_documentation&quot;:https://github.com/zipmark/rspec_api_documentation or what can be done by writing cucumber files (see for example &quot;cucumber docs on relishapp&quot;:http://www.relishapp.com/cucumber/cucumber/docs/cli/dry-run ).

BUT: I heard a lightening talk at this years &quot;wroc_love.rb&quot;:http://www.wrocloverb.com/ by &quot;LeFnord&quot;:https://github.com/LeFnord on the &quot;grape api gem&quot;:http://www.ruby-grape.org/ and his little baby &quot;grape-swagger&quot;:https://github.com/ruby-grape/grape-swagger which provides beautiful API documentation out of the box.

As our new API is to be consumed by a third Party we do need some documentation this time. Also we have some time to spare and are looking for a long term solution to our API-needs. We therefor decided to try out grape which is a framework independend of rails and does seem to do quite a lot of stuff in a reasonable manner :)


h3. Our first grape endpoint

First of to find out what we need to include to use grape inside a rails project. There is a gem which wraps the varios best practices of integrating grape into rails (&quot;grape_ape_rails&quot;:http://mepatterson.github.io/grape_ape_rails/ ) but it has not been maintained recently (last commit 2 years ago). Also it propably is better to add what is needed step by step to get to know the grape ecosystem. We therefor start of with adding

    gem &#39;grape&#39;

which is version 0.18.0 in our case.

Next up we have a look at the README. Wow - pages over pages. A lot more than the usual rails gems which consist of a five steps and finish approach. A bit overwhelming at first, especially as one has to filter out what&#39;s necessary for a rails project.

We create our first API endpoint (i call it that, found no other fitting name) by placing a ruby file under app/api. We have to follow rails conventions for naming classes/modules (i.e. filenames + folders) but we do not need to create a v1 folder to version our API. Instead grape allows us to define the version (and what strategy to use e.g. path or header) inside our endpoint.

&lt;pre&gt;
class Nirvana &lt; Grape::API
  version &#39;v1&#39;
  format :json
  prefix :api

  resource :cities do
    desc &#39;Return ten cities matching the query&#39;

    params do
      requires :q, type: String
    end
    get :all do
      City.search(params[&#39;q&#39;]).limit(10)
    end
  end

end
&lt;/pre&gt;

For our first tryout we include a simple cities resource using a query param.

Next up a test (yea next time we&#39;ll write that one first ;) ). we create a test/api directory to bundle up everything api related. The test does not differ much from usual model tests although this is more like an rails controller test.

&lt;pre&gt;
require &#39;test_helper&#39;

class NirvanaTest &lt; ActiveSupport::TestCase
  include Rack::Test::Methods

  def app
    Rails.application
  end

  test &#39;GET /api/statuses/public_timeline returns an empty array of statuses&#39; do
    get &#39;/api/v1/nirvana/cities&#39;
    assert last_response.ok?
    assert_equal [], JSON.parse(last_response.body)
  end

end
&lt;/pre&gt;

We need the app method so rack-test knows what to use. I wonder if there will be a point at which it might be nice to have a stricter seperation of testing as in rails (models, controllers, integration). Although an API of course is diffent.

First test run of course fails. We have not yet mounted the API nor loaded the app/api directory. Unfortunately test is still red. Now comes the hard part. How do we debug Grape inside of rails? First guess is to validate we actually are using the right route. Unfortunately our handy &#39;rake routes&#39; does not help with this. We therefor inspect &#39;Nirvana.routes&#39; on the console.

&lt;pre&gt;
 &gt; Nirvana.routes.map{|route| route.pattern.path}
 =&gt; [&quot;/api/:version/cities/all(.json)&quot;] 
 &lt;/pre&gt;

Okay, so the route consists of api-prefix + version + resource + action. I wonder if this is fixed or other parts may be inserted. It should be easier to print out grape routes than it is today. I tried out the &quot;grape-rails-routes&quot;:https://github.com/pmq20/grape-rails-routes gem but it does not seem to work with recent grape versions. Better luck with &quot;grape-raketasks&quot;:https://github.com/reprah/grape-raketasks which works although the printout could be a bit more compact:

&lt;pre&gt;
$ rake grape_raketasks:routes
ANCHOR:          true
API:             Nirvana
DESCRIPTION:     &quot;Return ten cities matching the query&quot;
FORWARD_MATCH:   nil
METHOD:          &quot;GET&quot;
NAMESPACE:       &quot;/cities&quot;
PARAMS:          {&quot;q&quot;=&gt;{:required=&gt;true, :type=&gt;&quot;String&quot;}}
PREFIX:          :api
REQUIREMENTS:    {}
SETTINGS:        {:description=&gt;{:description=&gt;&quot;Return ten cities matching the query&quot;, :params=&gt;{&quot;q&quot;=&gt;{:required=&gt;true, :type=&gt;&quot;String&quot;}}}, :declared_params=&gt;[:q]}
SUFFIX:          &quot;(.json)&quot;
VERSION:         &quot;v1&quot;
&lt;/pre&gt;

And thats for only one single endpoint - good luck with a real API.


h3. And now the documentation

Next up we want to generate some beautiful documentation for our API. For this we wil be using the grape-swagger gem which generates the docs. As we want to directly include them in our rails project we start off with the &quot;grape-swagger-rails&quot;:https://github.com/ruby-grape/grape-swagger-rails gem which allows us to mount the swagger UI as an engine. So off we go, follow the README, add gem, create initializer and open the swagger UI...

!{width: 100%}/assets/images/grape/grape-swagger-rails-ui-cant-read.png(Swagger UI is not working yet)!

Hmm... only kinda works :) We had to specify an url and app_url in an initializer. The example url was just a path to a json file. I guess it&#39;s supposed to be the &#39;Swagger API schema&#39;. Question is how to generate this. Seems as if swagger itself is not included in the grape-swagger-rails gem which in my opinion does not make sense or at least is not what one would expect from a rails gem. 

So let&#39;s install &quot;grape-swagger&quot;:https://github.com/ruby-grape/grape-swagger and set it up. We follow the README and create a root node:
&lt;pre&gt;
require &#39;grape-swagger&#39;

class Root &lt; Grape::API
  mount Nirvana
  add_swagger_documentation
end
&lt;/pre&gt;
But the suggested path &#39;localhost:3000/swagger_doc&#39; does not work for us. We just end up with an 404 from our rails app. Our rake grape routes gem also gives no hint as to which path to use. So after trying out a whole lot of different routes (for instance &#39;localhost:3000/api/v1/swagger_doc&#39;) we still do not know how to actually generate the swagger schema. Then lightening struck - the example given by grape-swagger mounts a couple of other endpoints. I thought this was only due to whats supposed to be included in the docs but then i realized the Root node is the one which should be mounted inside routes.rb. Only then the swagger_doc is accessible. For now the easiest is to simply include the &#39;add_swagger_documentation&#39; into our initial cities endpoint. Five seconds later after changing the schema url to &#39;api/v1/swagger_doc&#39;:

!/assets/images/grape/grape-swagger-ui-working.png(Yeah)!

Nice! A usable and intuitive documentation for our API. Some polishing still has to be done (for instance where will we set &#39;API title&#39;?) and some details are still puzzeling (i.e. why is there a 0.0.1 version shown in the footer when we specified v1 as our API version?). But all in all it&#39;s great :)

.h3 Conclusion

So all in all we have a nice API with great documentation generated for us. On the downside it is a pitty many of our trusted rails tools do not work and/or have to be reinvented. We will see how much overhead this adds to further developing the API and adding more advanced features such as authentication, caching or using JSON:API as format.</content>
 </entry>
 
 <entry>
   <title>Working around ubuntu server's most annoying /boot partition full</title>
   <link href="http://tamaloa.github.io/2013/11/11/ubuntu-servers-most-annoying-boot-partition-full"/>
   <updated>2013-11-11T00:00:00+01:00</updated>
   <id>http://tamaloa.github.io/2013/11/11/ubuntu-servers-most-annoying-boot-partition-full</id>
   <content type="html">

Ubuntu server editions (up to 12.04LTS) are mostly easy to take care of. With unattended security updates activated (as recommended by the installer) it is okay to focus on your own applications and to rely on the main system being okay.
Ubuntu frequently releases updated kernel images which are automatically installed. This works very well and old images are kept just in case the newly installed image fails.
Unfortunately older kernel images are kept indefinitely. This leads to the /boot partition slowly filling up. Additionally the default partioning (at least with a 100GB disk) provisions only ~230M for /boot. Thus in under a year /boot is filled which may cause the whole system to lock down (google for &quot;ubuntu /boot partition full&quot; and be shocked :)).

It seems wise to keep a few older images around just in case, but not 20 or more! The ubuntu guys seem to have noticed this as well [1] and newer Ubuntu releases (since 13.04) have a single command @sudo apt-get autoremove --purge@ to remove all old kernels except for the most recent two. Unfortunately there exists no single script to call in the most recent server-LTS and selecting all kernels by hand for several servers is really annoying. [UPDATE] I am now experiencing the same problem of /boot filling up on 14.04 server machines and the before mentioned single command does not take care of this. So the following script is also used for 14.04 servers.[/UPDATE]

The scripts on the web either removed all old kernels (keeping only the current and thus leaving no rollback opportunity) [2] or deleted all except for the youngest two (the current kernel could be older) [3]. Thus i put together the following script which purges all kernel images and headers except for the current running kernel (which is the output of uname -r), the actual base kernel and the two last kernels in the listing (propably the most recent ones and propably at least one has run successfully before :).

&lt;pre&gt;
#!/bin/bash

dpkg --get-selections | `#show all installed packages` \
  grep &#39;linux-image-*&#39; | `#select all installed images` \
  awk &#39;{print $1}&#39; | `#select only package name)` \
  egrep -v &quot;linux-image-$(uname -r)|linux-image-generic&quot; | `#remove current and base kernel from list` \
  head -n -2 | `#remove two recent kernels from list` \
  sed &#39;s/^linux-image-\(.*\)$/\1/&#39; | `#capture image version` \
  while read n
  do 
    echo &#39;Purging unneeded kernel images and headers for: &#39;$n
    sudo apt-get --yes purge linux-image-$n    #purge images
    sudo apt-get --yes purge linux-headers-$n  #purge headers
  done
&lt;/pre&gt;

If added to roots crontab via
&lt;pre&gt;
@reboot /root/purge-unneeded-kernels.sh
&lt;/pre&gt;
this hopefully keeps /boot well below 50% df.

Note - the &quot;adding comments to multiline shell command via backticks&quot; worked for me in some cases but in some i had to remove them to run the script :/

fn1.&quot;lists.ubuntu.com Distro-provided mechanism to clean up old kernels&quot;:https://lists.ubuntu.com/archives/ubuntu-devel/2012-February/034775.html

fn2.&quot;ubuntugenius.wordpress.com Blogpost&quot;:http://ubuntugenius.wordpress.com/2011/01/08/ubuntu-cleanup-how-to-remove-all-unused-linux-kernel-headers-images-and-modules/

fn3.&quot;lists.ubuntu.com shellscript&quot;:https://lists.ubuntu.com/archives/ubuntu-devel/2012-February/034767.html


</content>
 </entry>
 
 <entry>
   <title>Creating And Publishing A New Relic Passenger Plugin</title>
   <link href="http://tamaloa.github.io/2013/09/03/creating-and-publishing-a-newrelic-passenger-plugin"/>
   <updated>2013-09-03T00:00:00+02:00</updated>
   <id>http://tamaloa.github.io/2013/09/03/creating-and-publishing-a-newrelic-passenger-plugin</id>
   <content type="html">

&quot;New Relic&quot;:http://newrelic.com/ Plattform now allows custom agents to report performance metrics. There exist several SDK to pick from as well as an web API.

We use &quot;Phusion Passenger&quot;:https://www.phusionpassenger.com/‎ web server to deploy our Rails apps. New Relic already helps a lot in fixing performance issues inside the apps. Since we started using the New Relic server monitoring agents our previous setup has become somewhat obsolete. Prior we were running munin to gather statistics on our servers and applications. We were using the default ubuntu 12.04 packages with a custom theme (the built in one is just terrible). To monitor our rails apps we used the &quot;munin-plugin-rails&quot;:https://github.com/barttenbrinke/munin-plugins-rails gem which gathers data on

* rails apps by parsing the log files
* passenger web server by using the provided command line utilities

Parsing rails logs does provide some basic information on the applications performance. But it makes changing the Rails log formant difficult (and Rails log format is NOT production ready) and of course New Relic is just so much nicer to look at :)
The information gathered for passenger was still quite useful and not available in New Relic but munin is just really terrible if you actually want to do more than just have a quick look at the long term development (drilldown, setting timeperiods etc. is not possible). Also we wanted to know how much memory was used per Rails-App (we have a multiapp deploy per passenger webserver). So either we would have to add code to the munin plugins ... or try out the (kinda) new New Relic plugin architecture.

And yes - it is suprisingly easy to write a custom New Relic agent.

# Download Ruby example agent
# add some code to gather data (here easy: copy from munin gem)
  @passenger_status_output =~ /count\s+=\s+(\d+)/@
# send data to New Relic
  @report_metric &quot;passenger.processes.running&quot;, &quot;Processes&quot;, $1@
# start agent on your server (add your license key first)
# Metrics start to show up in New Relic UI
# Adjust UI (click, drag, drop, finished)


!/assets/images/newrelic-editing-plugin-dashboard_640.png(Screenshot showing editing the plugin dashboard)!

Later you can publish the Agent ... I have the feeling New Relic makes this harder than it should be. Most likely because there is no QA for the plugins listed in their plugins directory. I feel it would be easier if the UI configuration could be stored as a config file and versioned alongside the agent code. This would allow useful sharing of agents without the need of publishing them (i.e. if they really are just a hack - as this one :).

Anyway, reading the &quot;publishing documentation&quot;:https://newrelic.com/docs/plugin-dev/publishing-your-plugin-to-plugin-central makes you think it is real hard to publish a plugin. You need a company site, contact and support information and a whole load of requirements.

But actually you need no more than to host your plugin on github (or similar). This provides you with a webpage (github readme) a contact and support possibility (github issue page) and download link (github repository as zip link). Also the actual publishing process is a simple one page form ...

!/assets/images/newrelic-publishing-plugin_600.png(Screenshot of publishing form for a on New Relic plugin)!

And after accepting the &quot;terms of service stuff&quot;:https://rpm.newrelic.com/terms_of_service/developer (#TODO: Read them) the plugin appears at the bottom of the plugins directory


!/assets/images/newrelic-plugins-repository-with-freshly-published-plugin_640.png(Screenshot of plugins directory with the newly created plugin at the bottom)!



</content>
 </entry>
 
 <entry>
   <title>Diffing a fresh rails 3 app against a rails 4 app</title>
   <link href="http://tamaloa.github.io/2013/07/26/diff-rails3-rails4"/>
   <updated>2013-07-26T00:00:00+02:00</updated>
   <id>http://tamaloa.github.io/2013/07/26/diff-rails3-rails4</id>
   <content type="html">

In the process of migrating to rails 4 i like to know what has changed for the &quot;default&quot; app. The easiest way to check is to generate two new rails apps using the different rails versions and then comparing with a diff tool (i like meld :).

&lt;pre&gt;
gem install rails -v 3.2.14
rails new rails-3.2.14
gem install rails -v 4.0.0
rails new rails-4.0.0

meld rails-3.2.14 rails-4.0.0
&lt;/pre&gt;

The screenshot shows not too many large differences in the directory structure or filewise. Noticable is

* .gitkeep was renamed to .keep which i think is nice because we use mercurial :)
* a default index page (with corresponding image) no longer exists .. phew, saves deleting it every time
* the new concerns dir is added to app/controllers and app/models
* executables now have their place in bin
* config for filter_paramter_logging was added
* there no longer is a doc dir (who used it anyway?)
* test dirs now correspond to what is tested (unit == model, functional == controller) and new ones for helper and mailer testing were added.
* and of course plugins dir has finally been removed (remember all those deprecation warnings :)

!/assets/images/rails-3.2.14_vs_rails-4.0.0_diff.png(A diff of a newly created rails 3 vs rails 4 app)!


h3. Conclusion

...some time later :)
</content>
 </entry>
 
 
</feed>