<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Tamaloa's Blog</title>
        <description>Tamaloa's Blog - Michael</description>
        <link>http://tamaloa.github.io</link>
        <link>http://tamaloa.github.io</link>
        <lastBuildDate>2017-01-22T20:10:20+01:00</lastBuildDate>
        <pubDate>2017-01-22T20:10:20+01:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>More Advanced Features for Our Grape API</title>
                <description>
&lt;p&gt;After we got our intitial first Grape API up and running (including the
nice swagger documentation) we started adding more features.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Entities &amp;amp; Doc configuration&lt;/li&gt;
  &lt;li&gt;authentication via token&lt;/li&gt;
  &lt;li&gt;CORS configuration&lt;/li&gt;
  &lt;li&gt;JSON:API&lt;/li&gt;
  &lt;li&gt;caching&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;configuring-the-swagger-documentation&quot;&gt;Configuring the Swagger documentation&lt;/h3&gt;

&lt;p&gt;As nice as the default generated documentation is one always wants to
change it around a little. Some stuff we found unnecessary hard to do
other was easy.\
For instance the list of API endpoints is headed by a line autogenerated
from the API class name. This was okay until we modularized everything
and added a base API class. Suddenly the heading read “api: Operations
about apis” which does not make a lot of sense. This can be configured
by adding tags to EVERY route description. Below the example in which we
tagged all endpoints except for one:&lt;/p&gt;

&lt;p&gt;grape-swagger-tags-example.png&lt;/p&gt;

&lt;p&gt;Futhermore details and tags do not play along well. So we had to drop
the detailed explaination on one endpoint - will have to investigate
this bug later.\
Other stuff such as hiding the swagger json url or the token field is
simple and done by adding options to the ‘add_swagger_documentation’
call.&lt;/p&gt;

&lt;h3 id=&quot;grapeentity&quot;&gt;Grape::Entity&lt;/h3&gt;

&lt;p&gt;We then added an endpoint which returns not only a simple list of values
but a more complex model. This seemed the right time to add grape_entity
and the corresponding swagger gem. Entities are a kind of decorator,
that is a class in which you define what attributes/methods are to be
included and in which you also may do some formatting or rename
attributes to something your API consumers may understand.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module Entities
  class ServiceProvider &amp;lt; Grape::Entity
    expose :full_name, as: :name, documentation: { type: &#39;string&#39;,
            desc: &#39;Service provider company name in latin. If applicable may be followed by company name in non latin spelling.&#39;}
    expose :slug, documentation: { type: &#39;string&#39;, desc: &#39;Unique identifier in human readable form.&#39; }
    expose :url, documentation: { type: &#39;url&#39;, desc: &#39;The URL for this service provider in our application.&#39;}

    private
    def url
       Rails.application.routes.url_helpers.company_url(object, host: Figaro.env.base_url)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can se we renamed some attributes and included the URL under
which a user may visit our entity. Next we used our grape entity to
present our actual ActiveRecord objects ‘present service_providers,
with: Entities::service_providers’ which gave us a nice and compact json
response. We also hoped to easily add the documentation to our Swar UI.
This is mainly done by providing ‘entity:
Nirvana::Entities::ServiceProvider’ as a description parameter.&lt;/p&gt;

&lt;h3 id=&quot;authentication-via-token&quot;&gt;Authentication via Token&lt;/h3&gt;

&lt;p&gt;We already use a token based authentication for other parts of our
existing application. So naturally we want to reuse this feature. The
Swagger UI already has a placeholder for an api-key to be entered in the
navigation bar, so activating this feature should be easy. And right
enough it is simple to configure the Swagger-UI to always add the
current_user token to each api request.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GrapeSwaggerRails.options.before_action do
  GrapeSwaggerRails.options.api_key_name = &#39;api_token&#39;
  GrapeSwaggerRails.options.api_key_type = &#39;query&#39;
  GrapeSwaggerRails.options.api_key_default_value = current_user.authentication_token
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So by now the Swagger-UI adds the user specific api_token to every
request triggered inside the UI. Of course we now have to ensure the
token matches a user. For this we add a helpers block to our base API
class with appropiate methods. These can now be used in any mounted API
endpoint to authenticate our users.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class API &amp;lt; Grape::API
    helpers do
      def current_user
        User.authenticate_from_token!(params[:api_token])
      end

      def authenticate!
        error!(&#39;401 Unauthorized&#39;, 401) unless current_user
      end
    end
  end

  class Cities &amp;lt; Grape::API
    resource :cities do
      get :all do
        authenticate!
        City.all
      end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I would like to add the authenticate! call to all endpoints as a
default, similar to before filters in rails controllers but there does
not seem to exist a easy way of doing this so we will live with it for
now.\
Also currently the documentation does not say anything about the
authorization schema and how to use it. A potential user might miss the
api_token parameter. In Grape there exists a security_definition schema
which can be passed to the generated swagger documentation.
Unfortunately this definition is not reflected in Swagger-UI, at least
not in the version we use (bundled with grape-swagger-rails version
0.3.0) which is a pitty. Next try was to document the token as
additional query parameter. This for one turns out to be a bit much for
a nice clean documentation and also the parameter definition has to
again be added to each endpoint which generates a lot of code (again
some kind of default params for all endpoints would be nice).\
I am not yet decided but for now we will instead put some authentication
documentation in the general API documentation which is shown in Swagger
UI.&lt;/p&gt;

&lt;h3 id=&quot;cors&quot;&gt;CORS&lt;/h3&gt;

&lt;p&gt;To allow CORS (cross origin resource sharing) we add the rack-cors gem
and set our headers apropriately on the path under which our api is
served (this is done in the host rails project’s application.rb).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#In config/application.rb

    config.middleware.insert_before 0, &quot;Rack::Cors&quot; do
      allow do
        origins &#39;*&#39;
        resource &#39;/api/*&#39;, :headers =&amp;gt; :any, :methods =&amp;gt; [:get, :post, :options]
      end
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To ensure we do not remove our CORS configuration by accident a small
integration test (yes you need integration because otherwise rack is not
invoked) is added&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ApiConfigurationTest &amp;lt; ActionDispatch::IntegrationTest
  test &quot;CORS is set up only for our api&quot; do
    get &#39;/api/something&#39;, nil, &#39;HTTP_ORIGIN&#39; =&amp;gt; &#39;*&#39;
    assert_equal &#39;*&#39;, response.headers[&#39;Access-Control-Allow-Origin&#39;]

    get &#39;/no_corse_for_other_pahts&#39;, nil, &#39;HTTP_ORIGIN&#39; =&amp;gt; &#39;*&#39;
    refute_equal &#39;*&#39;, response.headers[&#39;Access-Control-Allow-Origin&#39;]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;and-now&quot;&gt;And now?&lt;/h3&gt;

&lt;p&gt;So we still had JSON:API and caching on our todo list but the above took
long enough so i will call it a day.\
Seems that JSON:API is not that easily integrated into grape. There
exists some basic implementations which are quite limited (for instance
do not support paging). So we will leave this for some other time.\
And other usefull stuff which you really should use in production
(caching, throtteling, loggging) will be left for some other time.&lt;/p&gt;
</description>
                <link>http://tamaloa.github.io/2016/12/08/more-advanced-features-for-our-grape-api</link>
                <guid>http://tamaloa.github.io/2016/12/08/more-advanced-features-for-our-grape-api</guid>
                <pubDate>2016-12-08T00:00:00+01:00</pubDate>
        </item>

        <item>
                <title>Using Grape to add an API to a brownfield Rails Project</title>
                <description>
&lt;p&gt;Starting point: We needed a small and simple API added to a several year
old rails 4.2 project. We already have some APIs in use in this project
which use basic rails controllers, ActiveModel, and sometimes jbuilder.
So quickest would be to just build the API as we did with all the
others. Maybe even use newish rails 5 ActionController::API and use
&lt;a href=&quot;http://jsonapi.org/&quot;&gt;json:api&lt;/a&gt; setting to have some kind of
standardization. Up to now we never needed real documentation (beside
the code) as we ourselves consumed the APIs. What seems a nice option
for API-docus is to use the test cases to generate the documentation as
does
&lt;a href=&quot;https://github.com/zipmark/rspec_api_documentation&quot;&gt;rspec_api_documentation&lt;/a&gt;
or what can be done by writing cucumber files (see for example &lt;a href=&quot;http://www.relishapp.com/cucumber/cucumber/docs/cli/dry-run&quot;&gt;cucumber
docs on
relishapp&lt;/a&gt;
).&lt;/p&gt;

&lt;p&gt;BUT: I heard a lightening talk at this years
&lt;a href=&quot;http://www.wrocloverb.com/&quot;&gt;wroc_love.rb&lt;/a&gt; by
&lt;a href=&quot;https://github.com/LeFnord&quot;&gt;LeFnord&lt;/a&gt; on the &lt;a href=&quot;http://www.ruby-grape.org/&quot;&gt;grape api
gem&lt;/a&gt; and his little baby
&lt;a href=&quot;https://github.com/ruby-grape/grape-swagger&quot;&gt;grape-swagger&lt;/a&gt; which
provides beautiful API documentation out of the box.&lt;/p&gt;

&lt;p&gt;As our new API is to be consumed by a third Party we do need some
documentation this time. Also we have some time to spare and are looking
for a long term solution to our API-needs. We therefor decided to try
out grape which is a framework independend of rails and does seem to do
quite a lot of stuff in a reasonable manner :)&lt;/p&gt;

&lt;h3 id=&quot;our-first-grape-endpoint&quot;&gt;Our first grape endpoint&lt;/h3&gt;

&lt;p&gt;First of to find out what we need to include to use grape inside a rails
project. There is a gem which wraps the varios best practices of
integrating grape into rails
(&lt;a href=&quot;http://mepatterson.github.io/grape_ape_rails/&quot;&gt;grape_ape_rails&lt;/a&gt; ) but
it has not been maintained recently (last commit 2 years ago). Also it
propably is better to add what is needed step by step to get to know the
grape ecosystem. We therefor start of with adding&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem &#39;grape&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;which is version 0.18.0 in our case.&lt;/p&gt;

&lt;p&gt;Next up we have a look at the README. Wow - pages over pages. A lot more
than the usual rails gems which consist of a five steps and finish
approach. A bit overwhelming at first, especially as one has to filter
out what’s necessary for a rails project.&lt;/p&gt;

&lt;p&gt;We create our first API endpoint (i call it that, found no other fitting
name) by placing a ruby file under app/api. We have to follow rails
conventions for naming classes/modules (i.e. filenames + folders) but we
do not need to create a v1 folder to version our API. Instead grape
allows us to define the version (and what strategy to use e.g. path or
header) inside our endpoint.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Nirvana &amp;lt; Grape::API
  version &#39;v1&#39;
  format :json
  prefix :api

  resource :cities do
    desc &#39;Return ten cities matching the query&#39;

    params do
      requires :q, type: String
    end
    get :all do
      City.search(params[&#39;q&#39;]).limit(10)
    end
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For our first tryout we include a simple cities resource using a query
param.&lt;/p&gt;

&lt;p&gt;Next up a test (yea next time we’ll write that one first ;) ). we create
a test/api directory to bundle up everything api related. The test does
not differ much from usual model tests although this is more like an
rails controller test.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require &#39;test_helper&#39;

class NirvanaTest &amp;lt; ActiveSupport::TestCase
  include Rack::Test::Methods

  def app
    Rails.application
  end

  test &#39;GET /api/statuses/public_timeline returns an empty array of statuses&#39; do
    get &#39;/api/v1/nirvana/cities&#39;
    assert last_response.ok?
    assert_equal [], JSON.parse(last_response.body)
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We need the app method so rack-test knows what to use. I wonder if there
will be a point at which it might be nice to have a stricter seperation
of testing as in rails (models, controllers, integration). Although an
API of course is diffent.&lt;/p&gt;

&lt;p&gt;First test run of course fails. We have not yet mounted the API nor
loaded the app/api directory. Unfortunately test is still red. Now comes
the hard part. How do we debug Grape inside of rails? First guess is to
validate we actually are using the right route. Unfortunately our handy
‘rake routes’ does not help with this. We therefor inspect
‘Nirvana.routes’ on the console.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;gt; Nirvana.routes.map{|route| route.pattern.path}
 =&amp;gt; [&quot;/api/:version/cities/all(.json)&quot;] 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Okay, so the route consists of api-prefix + version + resource + action.
I wonder if this is fixed or other parts may be inserted. It should be
easier to print out grape routes than it is today. I tried out the
&lt;a href=&quot;https://github.com/pmq20/grape-rails-routes&quot;&gt;grape-rails-routes&lt;/a&gt; gem
but it does not seem to work with recent grape versions. Better luck
with &lt;a href=&quot;https://github.com/reprah/grape-raketasks&quot;&gt;grape-raketasks&lt;/a&gt; which
works although the printout could be a bit more compact:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rake grape_raketasks:routes
ANCHOR:          true
API:             Nirvana
DESCRIPTION:     &quot;Return ten cities matching the query&quot;
FORWARD_MATCH:   nil
METHOD:          &quot;GET&quot;
NAMESPACE:       &quot;/cities&quot;
PARAMS:          {&quot;q&quot;=&amp;gt;{:required=&amp;gt;true, :type=&amp;gt;&quot;String&quot;}}
PREFIX:          :api
REQUIREMENTS:    {}
SETTINGS:        {:description=&amp;gt;{:description=&amp;gt;&quot;Return ten cities matching the query&quot;, :params=&amp;gt;{&quot;q&quot;=&amp;gt;{:required=&amp;gt;true, :type=&amp;gt;&quot;String&quot;}}}, :declared_params=&amp;gt;[:q]}
SUFFIX:          &quot;(.json)&quot;
VERSION:         &quot;v1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And thats for only one single endpoint - good luck with a real API.&lt;/p&gt;

&lt;h3 id=&quot;and-now-the-documentation&quot;&gt;And now the documentation&lt;/h3&gt;

&lt;p&gt;Next up we want to generate some beautiful documentation for our API.
For this we wil be using the grape-swagger gem which generates the docs.
As we want to directly include them in our rails project we start off
with the
&lt;a href=&quot;https://github.com/ruby-grape/grape-swagger-rails&quot;&gt;grape-swagger-rails&lt;/a&gt;
gem which allows us to mount the swagger UI as an engine. So off we go,
follow the README, add gem, create initializer and open the swagger
UI…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/grape/grape-swagger-rails-ui-cant-read.png&quot; alt=&quot;Swagger UI is not working yet&quot; title=&quot;Swagger UI is not working yet&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hmm… only kinda works :) We had to specify an url and app_url in an
initializer. The example url was just a path to a json file. I guess
it’s supposed to be the ‘Swagger API schema’. Question is how to
generate this. Seems as if swagger itself is not included in the
grape-swagger-rails gem which in my opinion does not make sense or at
least is not what one would expect from a rails gem.&lt;/p&gt;

&lt;p&gt;So let’s install
&lt;a href=&quot;https://github.com/ruby-grape/grape-swagger&quot;&gt;grape-swagger&lt;/a&gt; and set it
up. We follow the README and create a root node:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require &#39;grape-swagger&#39;

class Root &amp;lt; Grape::API
  mount Nirvana
  add_swagger_documentation
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;\
But the suggested path ‘localhost:3000/swagger_doc’ does not work for
us. We just end up with an 404 from our rails app. Our rake grape routes
gem also gives no hint as to which path to use. So after trying out a
whole lot of different routes (for instance
‘localhost:3000/api/v1/swagger_doc’) we still do not know how to
actually generate the swagger schema. Then lightening struck - the
example given by grape-swagger mounts a couple of other endpoints. I
thought this was only due to whats supposed to be included in the docs
but then i realized the Root node is the one which should be mounted
inside routes.rb. Only then the swagger_doc is accessible. For now the
easiest is to simply include the ‘add_swagger_documentation’ into our
initial cities endpoint. Five seconds later after changing the schema
url to ‘api/v1/swagger_doc’:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/grape/grape-swagger-ui-working.png&quot; alt=&quot;Yeah&quot; title=&quot;Yeah&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nice! A usable and intuitive documentation for our API. Some polishing
still has to be done (for instance where will we set ‘API title’?) and
some details are still puzzeling (i.e. why is there a 0.0.1 version
shown in the footer when we specified v1 as our API version?). But all
in all it’s great :)&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So all in all we have a nice API with great documentation generated for
us. On the downside it is a pitty many of our trusted rails tools do not
work and/or have to be reinvented. We will see how much overhead this
adds to further developing the API and adding more advanced features
such as authentication, caching or using JSON:API as format.&lt;/p&gt;
</description>
                <link>http://tamaloa.github.io/2016/12/05/using-grape-to-add-an-api-to-a-brownfield-rails-project</link>
                <guid>http://tamaloa.github.io/2016/12/05/using-grape-to-add-an-api-to-a-brownfield-rails-project</guid>
                <pubDate>2016-12-05T00:00:00+01:00</pubDate>
        </item>

        <item>
                <title>Working around ubuntu server's most annoying /boot partition full</title>
                <description>
&lt;p&gt;Ubuntu server editions (up to 12.04LTS) are mostly easy to take care of.
With unattended security updates activated (as recommended by the
installer) it is okay to focus on your own applications and to rely on
the main system being okay.
Ubuntu frequently releases updated kernel images which are automatically
installed. This works very well and old images are kept just in case the
newly installed image fails.
Unfortunately older kernel images are kept indefinitely. This leads to
the /boot partition slowly filling up. Additionally the default
partioning (at least with a 100GB disk) provisions only \~230M for
/boot. Thus in under a year /boot is filled which may cause the whole
system to lock down (google for “ubuntu /boot partition full” and be
shocked :)).&lt;/p&gt;

&lt;p&gt;It seems wise to keep a few older images around just in case, but not 20
or more! The ubuntu guys seem to have noticed this as well &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and
newer Ubuntu releases (since 13.04) have a single command
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get autoremove --purge&lt;/code&gt; to remove all old kernels except for
the most recent two. Unfortunately there exists no single script to call
in the most recent server-LTS and selecting all kernels by hand for
several servers is really annoying. [UPDATE] I am now experiencing the
same problem of /boot filling up on 14.04 server machines and the before
mentioned single command does not take care of this. So the following
script is also used for 14.04 servers.[/UPDATE]&lt;/p&gt;

&lt;p&gt;The scripts on the web either removed all old kernels (keeping only the
current and thus leaving no rollback opportunity) &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; or deleted all
except for the youngest two (the current kernel could be older) &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.
Thus i put together the following script which purges all kernel images
and headers except for the current running kernel (which is the output
of uname -r), the actual base kernel and the two last kernels in the
listing (propably the most recent ones and propably at least one has run
successfully before :).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

dpkg --get-selections | &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#show all installed packages` \&lt;/span&gt;
  grep &lt;span class=&quot;s1&quot;&gt;&#39;linux-image-*&#39;&lt;/span&gt; | &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#select all installed images` \&lt;/span&gt;
  awk &lt;span class=&quot;s1&quot;&gt;&#39;{print $1}&#39;&lt;/span&gt; | &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#select only package name)` \&lt;/span&gt;
  egrep -v &lt;span class=&quot;s2&quot;&gt;&quot;linux-image-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;uname -r&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;|linux-image-generic&quot;&lt;/span&gt; | &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#remove current and base kernel from list` \&lt;/span&gt;
  head -n -2 | &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#remove two recent kernels from list` \&lt;/span&gt;
  sed &lt;span class=&quot;s1&quot;&gt;&#39;s/^linux-image-\(.*\)$/\1/&#39;&lt;/span&gt; | &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#capture image version` \&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;n
  &lt;span class=&quot;k&quot;&gt;do 
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;Purging unneeded kernel images and headers for: &#39;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;
    sudo apt-get --yes purge linux-image-&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#purge images&lt;/span&gt;
    sudo apt-get --yes purge linux-headers-&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#purge headers&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If added to roots crontab via&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@reboot /root/purge-unneeded-kernels.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;\
this hopefully keeps /boot well below 50% df.&lt;/p&gt;

&lt;p&gt;Note - the “adding comments to multiline shell command via backticks”
worked for me in some cases but in some i had to remove them to run the
script :/&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://lists.ubuntu.com/archives/ubuntu-devel/2012-February/034775.html&quot;&gt;lists.ubuntu.com Distro-provided mechanism to clean up old
kernels&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://ubuntugenius.wordpress.com/2011/01/08/ubuntu-cleanup-how-to-remove-all-unused-linux-kernel-headers-images-and-modules/&quot;&gt;ubuntugenius.wordpress.com
Blogpost&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://lists.ubuntu.com/archives/ubuntu-devel/2012-February/034767.html&quot;&gt;lists.ubuntu.com
shellscript&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://tamaloa.github.io/2013/11/11/ubuntu-servers-most-annoying-boot-partition-full</link>
                <guid>http://tamaloa.github.io/2013/11/11/ubuntu-servers-most-annoying-boot-partition-full</guid>
                <pubDate>2013-11-11T00:00:00+01:00</pubDate>
        </item>

        <item>
                <title>Creating And Publishing A New Relic Passenger Plugin</title>
                <description>
&lt;p&gt;&lt;a href=&quot;http://newrelic.com/&quot;&gt;New Relic&lt;/a&gt; Plattform now allows custom agents to
report performance metrics. There exist several SDK to pick from as well
as an web API.&lt;/p&gt;

&lt;p&gt;We use &lt;a href=&quot;https://www.phusionpassenger.com/‎&quot;&gt;Phusion Passenger&lt;/a&gt; web server
to deploy our Rails apps. New Relic already helps a lot in fixing
performance issues inside the apps. Since we started using the New Relic
server monitoring agents our previous setup has become somewhat
obsolete. Prior we were running munin to gather statistics on our
servers and applications. We were using the default ubuntu 12.04
packages with a custom theme (the built in one is just terrible). To
monitor our rails apps we used the
&lt;a href=&quot;https://github.com/barttenbrinke/munin-plugins-rails&quot;&gt;munin-plugin-rails&lt;/a&gt;
gem which gathers data on&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rails apps by parsing the log files&lt;/li&gt;
  &lt;li&gt;passenger web server by using the provided command line utilities&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parsing rails logs does provide some basic information on the
applications performance. But it makes changing the Rails log formant
difficult (and Rails log format is NOT production ready) and of course
New Relic is just so much nicer to look at :)\
The information gathered for passenger was still quite useful and not
available in New Relic but munin is just really terrible if you actually
want to do more than just have a quick look at the long term development
(drilldown, setting timeperiods etc. is not possible). Also we wanted to
know how much memory was used per Rails-App (we have a multiapp deploy
per passenger webserver). So either we would have to add code to the
munin plugins … or try out the (kinda) new New Relic plugin
architecture.&lt;/p&gt;

&lt;p&gt;And yes - it is suprisingly easy to write a custom New Relic agent.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Download Ruby example agent&lt;/li&gt;
  &lt;li&gt;add some code to gather data (here easy: copy from munin gem)\
&lt;code class=&quot;highlighter-rouge&quot;&gt;passenger_status_output =~ /count\s+=\s+(\d+)/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;send data to New Relic\
&lt;code class=&quot;highlighter-rouge&quot;&gt;report_metric &quot;passenger.processes.running&quot;, &quot;Processes&quot;, $1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;start agent on your server (add your license key first)&lt;/li&gt;
  &lt;li&gt;Metrics start to show up in New Relic UI&lt;/li&gt;
  &lt;li&gt;Adjust UI (click, drag, drop, finished)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/newrelic-editing-plugin-dashboard_640.png&quot; alt=&quot;Screenshot showing editing the plugin dashboard&quot; title=&quot;Screenshot showing editing the plugin dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Later you can publish the Agent … I have the feeling New Relic makes
this harder than it should be. Most likely because there is no QA for
the plugins listed in their plugins directory. I feel it would be easier
if the UI configuration could be stored as a config file and versioned
alongside the agent code. This would allow useful sharing of agents
without the need of publishing them (i.e. if they really are just a
hack - as this one :).&lt;/p&gt;

&lt;p&gt;Anyway, reading the &lt;a href=&quot;https://newrelic.com/docs/plugin-dev/publishing-your-plugin-to-plugin-central&quot;&gt;publishing
documentation&lt;/a&gt;
makes you think it is real hard to publish a plugin. You need a company
site, contact and support information and a whole load of requirements.&lt;/p&gt;

&lt;p&gt;But actually you need no more than to host your plugin on github (or
similar). This provides you with a webpage (github readme) a contact and
support possibility (github issue page) and download link (github
repository as zip link). Also the actual publishing process is a simple
one page form …&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/newrelic-publishing-plugin_600.png&quot; alt=&quot;Screenshot of publishing form for a on New Relic plugin&quot; title=&quot;Screenshot of publishing form for a on New Relic plugin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And after accepting the &lt;a href=&quot;https://rpm.newrelic.com/terms_of_service/developer&quot;&gt;terms of service
stuff&lt;/a&gt; (#TODO: Read
them) the plugin appears at the bottom of the plugins directory&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/newrelic-plugins-repository-with-freshly-published-plugin_640.png&quot; alt=&quot;Screenshot of plugins directory with the newly created plugin at the bottom&quot; title=&quot;Screenshot of plugins directory with the newly created plugin at the bottom&quot; /&gt;&lt;/p&gt;

</description>
                <link>http://tamaloa.github.io/2013/09/03/creating-and-publishing-a-newrelic-passenger-plugin</link>
                <guid>http://tamaloa.github.io/2013/09/03/creating-and-publishing-a-newrelic-passenger-plugin</guid>
                <pubDate>2013-09-03T00:00:00+02:00</pubDate>
        </item>

        <item>
                <title>Diffing a fresh rails 3 app against a rails 4 app</title>
                <description>
&lt;p&gt;In the process of migrating to rails 4 i like to know what has changed
for the “default” app. The easiest way to check is to generate two new
rails apps using the different rails versions and then comparing with a
diff tool (i like meld :).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install rails -v 3.2.14
rails new rails-3.2.14
gem install rails -v 4.0.0
rails new rails-4.0.0

meld rails-3.2.14 rails-4.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The screenshot shows not too many large differences in the directory
structure or filewise. Noticable is&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.gitkeep was renamed to .keep which i think is nice because we use
mercurial :)&lt;/li&gt;
  &lt;li&gt;a default index page (with corresponding image) no longer exists ..
phew, saves deleting it every time&lt;/li&gt;
  &lt;li&gt;the new concerns dir is added to app/controllers and app/models&lt;/li&gt;
  &lt;li&gt;executables now have their place in bin&lt;/li&gt;
  &lt;li&gt;config for filter_paramter_logging was added&lt;/li&gt;
  &lt;li&gt;there no longer is a doc dir (who used it anyway?)&lt;/li&gt;
  &lt;li&gt;test dirs now correspond to what is tested (unit  model, functional 
controller) and new ones for helper and mailer testing were added.&lt;/li&gt;
  &lt;li&gt;and of course plugins dir has finally been removed (remember all
those deprecation warnings :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rails-3.2.14_vs_rails-4.0.0_diff.png&quot; alt=&quot;A diff of a newly created rails 3 vs rails 4 app&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;…some time later :)&lt;/p&gt;
</description>
                <link>http://tamaloa.github.io/2013/07/26/diff-rails3-rails4</link>
                <guid>http://tamaloa.github.io/2013/07/26/diff-rails3-rails4</guid>
                <pubDate>2013-07-26T00:00:00+02:00</pubDate>
        </item>


</channel>
</rss>
